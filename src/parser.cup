package parser;

import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import syntax.*;
import scala.Tuple2;
import scala.Tuple3;
import scala.collection.Map;
import scala.collection.JavaConversions;
import java.util.HashMap;
import java.io.InputStream;
import java.io.InputStreamReader;

parser code {:
    public Parser(Lexer lexer, ComplexSymbolFactory csf) { super(lexer, csf); }

    public static Tuple3<Proc, Map<String, Name>, Name>
            parseStream(InputStream input) throws Exception {

        ComplexSymbolFactory csf = new ComplexSymbolFactory();
        Lexer lexer = new Lexer(new InputStreamReader(input), csf);
        Proc parsedTerm = (Proc)
                (new Parser(new ScannerBuffer(lexer), csf).parse().value);
        Tuple2<HashMap<String, Name>, Name> nameInfo =
                lexer.getNameInfo();
        Map<String, Name> scalaNameMap =
                JavaConversions.mapAsScalaMap(nameInfo._1);
        return new Tuple3<Proc, Map<String, Name>, Name>
                (parsedTerm, scalaNameMap, nameInfo._2);
    }
:};

terminal            BANG    ,
                    QMARK   ,
                    STAR    ,
                    LSQUAR  ,
                    RSQUAR  ,
                    DOT     ,
                    LET     ,
                    NEW     ,
                    IF      ,
                    THEN    ,
                    ELSE    ,
                    BAR     ,
                    END     ,
                    LPAREN  ,
                    RPAREN  ,
                    LCURLY  ,
                    RCURLY  ,
                    TRUE    ,
                    FALSE   ,
                    PLUS    ,
                    DASH    ,
                    FSLASH  ,
                    PERC    ,
                    EQUAL   ,
                    EQEQ    ,
                    NEQ     ,
                    LESS    ,
                    LESSEQ  ,
                    GRTR    ,
                    GRTREQ  ,
                    AND     ,
                    OR      ;
terminal Name       CHAN    ,
                    IDENT   ;
terminal int        INT     ;

non terminal Proc   p;
non terminal Exp    e;
non terminal BinOp  o;

precedence left PLUS, DASH;
precedence left STAR, FSLASH;
precedence left PERC;
precedence left AND, OR;
precedence nonassoc EQEQ, NEQ, LESS, LESSEQ, GRTR, GRTREQ;
precedence nonassoc BAR;
precedence nonassoc DOT;

start with p;

p ::= CHAN:ch BANG LSQUAR e:msg RSQUAR DOT p:proc
        {: RESULT = new Send(new ChanLiteral(ch), msg, proc);               :}
    | CHAN:ch QMARK LSQUAR IDENT:bind RSQUAR DOT p:proc
        {: RESULT = new Receive(false, new ChanLiteral(ch), bind, proc);    :}
    | CHAN:ch QMARK STAR LSQUAR IDENT:bind RSQUAR DOT p:proc
        {: RESULT = new Receive(true, new ChanLiteral(ch), bind, proc);     :}
    | LCURLY e:ch RCURLY BANG LSQUAR e:msg RSQUAR DOT p:proc
        {: RESULT = new Send(ch, msg, proc);                                :}
    | LCURLY e:ch RCURLY QMARK LSQUAR IDENT:bind RSQUAR DOT p:proc
        {: RESULT = new Receive(false, ch, bind, proc);                     :}
    | LCURLY e:ch RCURLY QMARK STAR LSQUAR IDENT:bind RSQUAR DOT p:proc
        {: RESULT = new Receive(true, ch, bind, proc);                      :}
    | LET IDENT:bind EQUAL e:value DOT p:proc
        {: RESULT = new LetIn(bind, value, proc);                           :}
    | IF e:cond THEN p:proct ELSE p:procf
        {: RESULT = new IfThenElse(cond, proct, procf);                     :}
    | p:proc1 BAR p:proc2
        {: RESULT = new Parallel(proc1, proc2);                             :}
    | NEW IDENT:bind DOT p:proc
        {: RESULT = new Restrict(bind, proc);                               :}
    | END                   {: RESULT = End$.MODULE$;   :}
    | LPAREN p:proc RPAREN  {: RESULT = proc;           :}
    ;

e ::= IDENT:name            {: RESULT = new Variable(name);     :}
    | CHAN:ch               {: RESULT = new ChanLiteral(ch);    :}
    | INT:x                 {: RESULT = new IntLiteral(x);      :}
    | TRUE                  {: RESULT = new BoolLiteral(true);  :}
    | FALSE                 {: RESULT = new BoolLiteral(false); :}
    | e:l o:op e:r          {: RESULT = new BinExp(op, l, r);   :}
    | BANG e:exp            {: RESULT = new Not(exp);           :}
    | LPAREN e:exp RPAREN   {: RESULT = exp;                    :}
    ;

o ::= PLUS          {: RESULT = Add$.MODULE$;       :}
    | DASH          {: RESULT = Sub$.MODULE$;       :}
    | STAR          {: RESULT = Mul$.MODULE$;       :}
    | FSLASH        {: RESULT = Div$.MODULE$;       :}
    | PERC          {: RESULT = Mod$.MODULE$;       :}
    | EQEQ          {: RESULT = Equal$.MODULE$;     :}
    | NEQ           {: RESULT = NotEqual$.MODULE$;  :}
    | LESS          {: RESULT = Less$.MODULE$;      :}
    | LESSEQ        {: RESULT = LessEq$.MODULE$;    :}
    | GRTR          {: RESULT = Greater$.MODULE$;   :}
    | GRTREQ        {: RESULT = GreaterEq$.MODULE$; :}
    | AND           {: RESULT = And$.MODULE$;       :}
    | OR            {: RESULT = Or$.MODULE$;        :}
    ;
